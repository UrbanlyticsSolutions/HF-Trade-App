<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HF-Trade Real-Time Predictions</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0e27;
            --bg-card: rgba(21, 25, 50, 0.8);
            --accent-blue: #3b82f6;
            --accent-green: #10b981;
            --accent-red: #ef4444;
            --accent-purple: #8b5cf6;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --border-color: rgba(148, 163, 184, 0.1);
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 2rem;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 3rem;
        }

        h1 {
            font-size: 3rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1.125rem;
        }

        .status {
            text-align: center;
            padding: 1rem;
            margin-bottom: 2rem;
            background: var(--bg-card);
            border-radius: 0.5rem;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
        }

        .status.connected {
            border-color: var(--accent-green);
        }

        .status.error {
            border-color: var(--accent-red);
        }

        .status-subtext {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .metric-card {
            background: var(--bg-card);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-radius: 1rem;
            padding: 1.5rem;
            transition: all 0.3s ease;
        }

        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            border-color: var(--accent-blue);
        }

        .metric-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }

        .metric-value {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 0.25rem;
        }

        .metric-change {
            font-size: 0.875rem;
            font-weight: 500;
        }

        .positive {
            color: var(--accent-green);
        }

        .negative {
            color: var(--accent-red);
        }

        .chart-section {
            background: var(--bg-card);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-radius: 1rem;
            padding: 2rem;
            margin-bottom: 2rem;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .chart-title {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .timeframe-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .timeframe-btn {
            padding: 0.5rem 1rem;
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid var(--accent-blue);
            color: var(--accent-blue);
            border-radius: 0.5rem;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .timeframe-btn:hover {
            background: rgba(59, 130, 246, 0.2);
        }

        .timeframe-btn.active {
            background: var(--accent-blue);
            color: white;
        }

        .chart-wrapper {
            position: relative;
            height: 500px;
            margin-bottom: 1rem;
        }

        @media (max-width: 768px) {
            body {
                padding: 1rem;
            }

            h1 {
                font-size: 2rem;
            }

            .chart-wrapper {
                height: 300px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>HF-Trade Real-Time Predictions</h1>
            <p class="subtitle">Live ML predictions from trained model</p>
        </header>

        <div class="status" id="apiStatus">
            <span id="statusText">Connecting to API...</span>
            <span id="lastUpdated" class="status-subtext">Waiting for first update…</span>
        </div>

        <!-- Real-Time Prediction Dashboard -->
        <div class="metrics-grid">
            <div class="metric-card">
                <div class="metric-label">Next Bar Prediction</div>
                <div class="metric-value" id="nextPrediction">--</div>
                <div class="metric-change" id="predictionProb">Loading...</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Current Trend</div>
                <div class="metric-value" id="currentTrend">--</div>
                <div class="metric-change" id="trendStrength">Loading...</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Price Target</div>
                <div class="metric-value" id="priceTarget">--</div>
                <div class="metric-change" id="targetChange">Loading...</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Model Confidence</div>
                <div class="metric-value" id="modelAccuracy">--</div>
                <div class="metric-change" id="accuracyNote">Real-time from API</div>
            </div>
        </div>

        <!-- Main Price Chart -->
        <div class="chart-section">
            <div class="chart-header">
                <h2 class="chart-title">Price & ML Predictions (QQQ)</h2>
                <div class="timeframe-buttons">
                    <button class="timeframe-btn active" data-period="30m"
                        onclick="changeTimeframe('30m', this)">30M</button>
                    <button class="timeframe-btn" onclick="changeTimeframe(1, this)">1D</button>
                    <button class="timeframe-btn" onclick="changeTimeframe(5, this)">5D</button>
                    <button class="timeframe-btn" onclick="changeTimeframe(10, this)">10D</button>
                    <button class="timeframe-btn" onclick="changeTimeframe(20, this)">20D</button>
                    <button class="timeframe-btn" onclick="resetZoom()">Reset Zoom</button>
                </div>
            </div>
            <div class="chart-wrapper">
                <canvas id="priceChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        const DATA_URL = './live_data.json';

        if (typeof Chart !== 'undefined' && typeof chartjsPluginZoom !== 'undefined') {
            Chart.register(chartjsPluginZoom);
        }
        let priceChart;
        let chartData = [];
        let currentTimeframe = 1; // Used for day ranges
        let chartMode = 'minutes';
        let recentMinutes = 30;
        const MAX_RECENT_BARS = 100;

        // Update API status
        function updateStatus(connected, message) {
            const statusEl = document.getElementById('apiStatus');
            const textEl = document.getElementById('statusText');

            statusEl.className = 'status ' + (connected ? 'connected' : 'error');
            textEl.textContent = message;
        }

        function updateLastTimestamp(ts) {
            const subtext = document.getElementById('lastUpdated');
            if (!ts) {
                subtext.textContent = 'No data received yet';
                return;
            }
            const dt = new Date(ts);
            const localeString = dt.toLocaleString(undefined, {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            subtext.textContent = `Last bar: ${dt.toLocaleDateString()} ${localeString}`;
        }

        // Change timeframe
        function changeTimeframe(period, button) {
            // Update button states
            document.querySelectorAll('.timeframe-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            if (button) {
                button.classList.add('active');
            }

            resetZoom();

            if (period === '30m') {
                chartMode = 'minutes';
                recentMinutes = 30;
                fetchData();
            } else {
                // For now, historical data is not synced to static file
                alert("Historical data > 30m is not available in this live view.");
            }
        }

        // Fetch data from static JSON
        async function fetchData() {
            try {
                // Add timestamp to prevent caching
                const response = await fetch(`${DATA_URL}?t=${new Date().getTime()}`);
                if (!response.ok) throw new Error('Data file not found');

                const fullData = await response.json();

                // Update Prediction
                updateStatus(true, `✅ Connected - Live Data`);
                updatePredictionUI(fullData.prediction);

                // Update Chart
                const data = fullData.chart_data;
                chartData = data.data.slice(-MAX_RECENT_BARS);
                updateChart();
                updateLastTimestamp(chartData.length ? chartData[chartData.length - 1].timestamp : null);

            } catch (error) {
                console.error('Error fetching data:', error);
                updateStatus(false, '❌ Waiting for data update...');
            }
        }

        function getTimeframeLabel() {
            if (chartMode === 'minutes') {
                return `last ${recentMinutes} minutes`;
            }
            return `${currentTimeframe}D history`;
        }

        // Update prediction UI
        function updatePredictionUI(data) {
            // Direction
            const direction = data.prediction.direction;
            const confidence = data.prediction.confidence;
            let color;

            if (direction === 'UP') color = 'var(--accent-green)';
            else if (direction === 'DOWN') color = 'var(--accent-red)';
            else color = 'var(--text-secondary)';

            document.getElementById('nextPrediction').textContent = direction;
            document.getElementById('nextPrediction').style.color = color;
            document.getElementById('predictionProb').textContent = `Confidence: ${confidence.toFixed(1)}%`;

            // Trend
            const trend = data.trend.direction;
            const trendColor = trend === 'BULLISH' ? 'var(--accent-green)' : 'var(--accent-red)';

            document.getElementById('currentTrend').textContent = trend;
            document.getElementById('currentTrend').style.color = trendColor;
            document.getElementById('trendStrength').textContent = `${data.trend.strength} (ADX: ${data.trend.adx.toFixed(1)})`;
            document.getElementById('trendStrength').className = trend === 'BULLISH' ? 'metric-change positive' : 'metric-change negative';

            // Target
            const currentPrice = data.current_price;
            const targetPrice = data.target_price;
            const priceDiff = targetPrice - currentPrice;
            const percentChange = (priceDiff / currentPrice) * 100;

            document.getElementById('priceTarget').textContent = `$${targetPrice.toFixed(2)}`;
            document.getElementById('targetChange').textContent = `${priceDiff >= 0 ? '+' : ''}$${priceDiff.toFixed(2)} (${percentChange >= 0 ? '+' : ''}${percentChange.toFixed(2)}%)`;
            document.getElementById('targetChange').className = priceDiff >= 0 ? 'metric-change positive' : 'metric-change negative';

            // Confidence
            document.getElementById('modelAccuracy').textContent = `${confidence.toFixed(1)}%`;
        }

        // Initialize chart
        function initChart() {
            const ctx = document.getElementById('priceChart').getContext('2d');

            priceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'Price',
                            data: [],
                            borderColor: '#3b82f6',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0
                        },
                        {
                            label: 'MA20',
                            data: [],
                            borderColor: '#10b981',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.4,
                            pointRadius: 0
                        },
                        {
                            label: 'MA50',
                            data: [],
                            borderColor: '#f59e0b',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.4,
                            pointRadius: 0
                        },
                        {
                            label: 'ML Predictions',
                            data: [],
                            borderColor: '#8b5cf6',
                            backgroundColor: 'rgba(139, 92, 246, 0.1)',
                            borderWidth: 3,
                            borderDash: [8, 4],
                            fill: true,
                            tension: 0.4,
                            pointRadius: 1,
                            pointBackgroundColor: '#8b5cf6'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: '#94a3b8',
                                usePointStyle: true,
                                padding: 15
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(15, 23, 42, 0.9)',
                            titleColor: '#f8fafc',
                            bodyColor: '#cbd5e1',
                            padding: 12,
                            callbacks: {
                                label: function (context) {
                                    return context.dataset.label + ': $' + context.parsed.y.toFixed(2);
                                }
                            }
                        },
                        zoom: {
                            limits: {
                                x: { minRange: 5 * 60 * 1000 } // at least 5 minutes
                            },
                            pan: {
                                enabled: true,
                                mode: 'x',
                                modifierKey: 'shift'
                            },
                            zoom: {
                                wheel: {
                                    enabled: true,
                                    modifierKey: 'ctrl'
                                },
                                pinch: {
                                    enabled: true
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: 'rgba(59, 130, 246, 0.15)'
                                },
                                mode: 'x'
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'hour',
                                displayFormats: {
                                    hour: 'MMM dd HH:mm',
                                    day: 'MMM dd'
                                }
                            },
                            grid: { color: 'rgba(148, 163, 184, 0.1)' },
                            ticks: { color: '#94a3b8', maxRotation: 45, minRotation: 0 }
                        },
                        y: {
                            grid: { color: 'rgba(148, 163, 184, 0.1)' },
                            ticks: {
                                color: '#94a3b8',
                                callback: value => '$' + value.toFixed(2)
                            }
                        }
                    }
                }
            });
        }

        // Update chart with data
        function updateChart() {
            if (!chartData || chartData.length === 0) return;

            priceChart.data.datasets[0].data = chartData.map(d => ({ x: new Date(d.timestamp), y: d.close || d.price }));
            priceChart.data.datasets[1].data = chartData.map(d => ({ x: new Date(d.timestamp), y: d.ma20 }));
            priceChart.data.datasets[2].data = chartData.map(d => ({ x: new Date(d.timestamp), y: d.ma50 || d.ma20 }));
            priceChart.data.datasets[3].data = chartData.map(d => ({ x: new Date(d.timestamp), y: d.prediction }));

            // Adjust time unit based on timeframe
            if (chartMode === 'minutes') {
                priceChart.options.scales.x.time.unit = 'minute';
            } else if (currentTimeframe > 5) {
                priceChart.options.scales.x.time.unit = 'day';
            } else if (currentTimeframe > 1) {
                priceChart.options.scales.x.time.unit = 'hour';
            } else {
                priceChart.options.scales.x.time.unit = 'hour';
            }

            enforceRecentWindow();
            priceChart.update('none');
        }

        function enforceRecentWindow() {
            if (!priceChart || chartData.length === 0) return;
            const lastPoint = chartData[chartData.length - 1];
            if (!lastPoint || !lastPoint.timestamp) return;
            const lastTs = new Date(lastPoint.timestamp).getTime();

            let windowMs;
            if (chartMode === 'minutes') {
                windowMs = recentMinutes * 60 * 1000;
            } else {
                windowMs = currentTimeframe * 24 * 60 * 60 * 1000;
            }

            const minIdx = Math.max(0, chartData.length - MAX_RECENT_BARS);
            const fallbackStart = new Date(chartData[minIdx].timestamp).getTime();
            const minTs = chartMode === 'minutes' ? Math.max(lastTs - windowMs, fallbackStart) : fallbackStart;

            priceChart.options.scales.x.min = minTs;
            priceChart.options.scales.x.max = lastTs;
        }

        function resetZoom() {
            if (priceChart) {
                priceChart.resetZoom();
            }
        }

        // Initialize
        window.addEventListener('load', async () => {
            initChart();

            // Initial fetch
            await fetchData();

            // Update every 30 seconds (matching the git push interval)
            setInterval(async () => {
                await fetchData();
            }, 30000);
        });
    </script>
</body>

</html>